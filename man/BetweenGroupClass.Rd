% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BetweenGroupClass.R
\name{BetweenGroupClass}
\alias{BetweenGroupClass}
\title{Encapsulated OO class for between-group spread models}
\description{
This is a general-purpose between-group model spread class that takes a list
of within-group spread models as input, and provides methods to update/run
(and save/reset) these models while taking care of between-group
(density-dependent) spread by calculating and inputting trans_external for
each of the groups as appropriate based on the beta_matrix, which can be
modified as needed (see examples).

The input models can either be created using the \link{make_group} function,
or they can be your own R6 (or C++) class that implement the necessary methods
and fields (i.e. reset, save, update, I, state, and trans_external). The
models need not all be the same subtype, i.e. you can mix SIR/SEIR/SI models
and even R6 and C++ implementations.

Note that the between-group model stores a reference to (i.e. shallow copy of)
the input models, so you can see the state of the input groups being modified
as the between-group model runs. You can also change the state of these groups
at any time between updates/runs, either by modifying the groups used to create
the between-group model class or by using the (read-only) active binding groups
to retrieve one or more reference to a group. Of course you can also change
the beta_matrix at any time between updates/runs.
}
\examples{
## Create a list of groups:
groups <- list(
  make_group("stochastic", group_name="Group1"),
  make_group("stochastic", group_name="Group2")
)

## Modify the starting conditions as needed:
groups[[1]]$S <- 100
groups[[1]]$I <- 0
groups[[2]]$S <- 99
groups[[2]]$I <- 1
## etc

## Create a between-group model:
model <- BetweenGroupClass$new(groups)

## Modify beta_matrix as needed:
model$beta_matrix <- matrix(c(0,0.1,0.01,0), nrow=2, ncol=2)

## Then run the model:
output <- model$run(21, d_time=0.1)
ggplot2::autoplot(output)

## Change the beta_matrix to e.g. remove transmission from Group1->Group2:
model$beta_matrix <- matrix(c(0,0,0.01,0), nrow=2, ncol=2)
## And run for more time points:
output2 <- model$run(21, d_time=0.1)
ggplot2::autoplot(output2)

## To combine time points:
all_output <- dplyr::bind_rows(output, output2)
summary(all_output)

}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{beta_matrix}}{a matrix representing between-group (density-dependent) spread}

\item{\code{groups}}{a list of the internally-stored within-group models (this can be used to directly check and/or modify their state and/or parameters)}

\item{\code{time}}{the current time point}

\item{\code{transmission_between}}{the between-group transmission type (frequency or density)}

\item{\code{state}}{a data frame of the current state of each group}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-BetweenGroupClass-new}{\code{BetweenGroupClass$new()}}
\item \href{#method-BetweenGroupClass-update}{\code{BetweenGroupClass$update()}}
\item \href{#method-BetweenGroupClass-save}{\code{BetweenGroupClass$save()}}
\item \href{#method-BetweenGroupClass-reset}{\code{BetweenGroupClass$reset()}}
\item \href{#method-BetweenGroupClass-run}{\code{BetweenGroupClass$run()}}
\item \href{#method-BetweenGroupClass-run_until}{\code{BetweenGroupClass$run_until()}}
\item \href{#method-BetweenGroupClass-print}{\code{BetweenGroupClass$print()}}
\item \href{#method-BetweenGroupClass-clone}{\code{BetweenGroupClass$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-new"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-new}{}}}
\subsection{Method \code{new()}}{
Create a new between-group model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$new(groups)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{groups}}{a list of within-group models as either R6 or C++ classes (see e.g. \link{make_group})}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new between-group model object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-update"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-update}{}}}
\subsection{Method \code{update()}}{
Update the state of each group for a single time point, including
setting trans_external based on the value of the beta_matrix and vector
of I obtained from the groups (density-dependent spread).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$update(d_time)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{d_time}}{the desired time step (delta time)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
self, invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-save"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-save}{}}}
\subsection{Method \code{save()}}{
Instruct each group to save the current state and parameter values for later retrieval using reset()
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$save()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
self, invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-reset"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-reset}{}}}
\subsection{Method \code{reset()}}{
Instruct each group to reset the current state and parameter values to their last saved state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$reset()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
self, invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-run"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-run}{}}}
\subsection{Method \code{run()}}{
Update the state of each group for a given number of time points
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$run(add_time, d_time)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{add_time}}{the additional time to add to the current time of the model}

\item{\code{d_time}}{the desired time step (delta time)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a data frame of the model state at each (new) time point
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-run_until"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-run_until}{}}}
\subsection{Method \code{run_until()}}{
Update the state of each group for several time points, until a stopping
criterion is met.
NOTE: this method is a stub: it has not yet been implemented!
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$run_until(criterion_fun, d_time)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{criterion_fun}}{a function taking an input data frame of states and returning a logical scalar indicating if the simulation should be stopped (TRUE) or continue to be
updated (FALSE)}

\item{\code{d_time}}{the desired time step (delta time)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a data frame of the model state at each (new) time point
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-print"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-print}{}}}
\subsection{Method \code{print()}}{
Print method showing the number of groups and current time
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$print()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
self, invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-BetweenGroupClass-clone"></a>}}
\if{latex}{\out{\hypertarget{method-BetweenGroupClass-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{BetweenGroupClass$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
